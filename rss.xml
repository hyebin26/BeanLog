<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Gatsby Starter Blog RSS Feed]]></title><description><![CDATA[A starter blog demonstrating what Gatsby can do.]]></description><link>https://gatsbystarterblogsource.gatsbyjs.io</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 15 Feb 2022 09:01:21 GMT</lastBuildDate><item><title><![CDATA[Next.js에 대해 알아보자]]></title><description><![CDATA[Next.js 우선 Next.js는 React의 프레임워크입니다. 그럼 React의 어떤 문제를 해결하기 위해서 이러한 프레임워크가 탄생하게 됬는지 살펴보겠습니다. 코드는 webpack과 같은 번들러를 사용하여 번들링되고 Babel…]]></description><link>https://gatsbystarterblogsource.gatsbyjs.io/React/Next/</link><guid isPermaLink="false">https://gatsbystarterblogsource.gatsbyjs.io/React/Next/</guid><pubDate>Invalid Date</pubDate><content:encoded>&lt;h1&gt;Next.js&lt;/h1&gt;
&lt;p&gt;우선 Next.js는 React의 프레임워크입니다. 그럼 React의 어떤 문제를 해결하기 위해서 이러한 프레임워크가 탄생하게 됬는지 살펴보겠습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;코드는 webpack과 같은 번들러를 사용하여 번들링되고 Babel과 같은 컴파일러를 사용하여 변환되어야 합니다.&lt;/li&gt;
&lt;li&gt;code splitting 같은 production 최적화를 할 수가 없습니다.&lt;/li&gt;
&lt;li&gt;Client Side Rendering이기 때문에 SEO를 적용할 수 없습니다.&lt;/li&gt;
&lt;li&gt;React 앱을 데이터 저장소 연결 등 서버 측 코드를 작성할 수 없습니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;다른 React 프레임워크도 이러한 문제들을 해결할 수 있습니다. 하지만 프레임워크는 높은 수준의 추상화를 필요로 하고, 또한 이것은 높은 수준의 개발경험이 있어야 팀이 코드를 쉽게 작성할 수 있습니다.&lt;/p&gt;
&lt;p&gt;Next.js는 이러한 문제들에 해결책을 제공하고, React 앱을 구축할 때 당신의 팀을 성공하기 쉽게 만들어줍니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;Gatsby는?&lt;/h3&gt;
&lt;p&gt;Gatsby는 위와 비슷하게 Client Side Rendering의 단점을 해결하기 위해 나온 프레임워크입니다. Gatsby는 React로 구성된 코드를 빌드할 때 React의 구성요소를 Public폴더에서 정적인 HTML페이지로 렌더링합니다(Static Site Generation). 즉, React로 구성된 코드를 정적인 파일로 미리 생성하고 서버에 배포해놓는 구조입니다.&lt;/p&gt;
&lt;p&gt;하지만 웹페이지가 모두 정적인 것이 아니라, 유저가 HTML을 보고 있을 때 React 구성요소를 다운받고 실행하고 리액트는 HTML과 동기화(Sync)되어서 동적인 요소도 추가할 수 있습니다.&lt;/p&gt;
&lt;p&gt;넥스트 배경&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;Next.js의 장점&lt;/h3&gt;
&lt;p&gt;Next는 SSG도 지원하고, SSR(Server Side Rendering),CSR도 지원해서 목적에 알맞게 사용할 수 있습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Dynamic Routing과 함께 직관적인 페이지 기반 라우팅 시스템&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://nextjs.org/docs/basic-features/pages#pre-rendering&quot;&gt;Pre-rendering&lt;/a&gt;, SSG 그리고 SSR 사용 가능&lt;/li&gt;
&lt;li&gt;빠른 페이지 로딩을 위한 Automatic Code Splitting&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://nextjs.org/docs/routing/introduction#linking-between-pages&quot;&gt;Client-side routing&lt;/a&gt;에 최적화된 Prefetching&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://nextjs.org/docs/basic-features/fast-refresh&quot;&gt;Fast Refresh&lt;/a&gt;와 함께 빠른 개발 환경&lt;/li&gt;
&lt;li&gt;Serverless Functions으로 API엔드포인트를 빌드하기 위한 &lt;a href=&quot;https://nextjs.org/docs/api-routes/introduction&quot;&gt;API routes&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3&gt;Pre-rendering&lt;/h3&gt;
&lt;p&gt;Next.js는 default로 모든페이지가 &lt;strong&gt;pre-render&lt;/strong&gt;가 된다. 즉, Next.js는 클라이언트 측 Javascript로 모든 작업을 수행하는 대신 각 페이지에 대해 미리 HTML을 생성합니다. P&lt;strong&gt;re-render은 더 나은 성능과 SEO로 이어질 수 있습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;만들어진 HTML은 페이지에 꼭 필요한 최소한의 코드로 이루어져 있습니다. 브라우저에 의해 페이지가 로드되었을 때, Javascript code는 동작되고 페이지를 전체적으로 interactive하게 만듭니다.&lt;/p&gt;
&lt;p&gt;Rendering Form은 두 가지가 존재합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Static Generation(Recommended): HTML은 &lt;strong&gt;build time&lt;/strong&gt;에 생성되고 각각의 요청마다 재사용될 수 있습니다. 이것은 &lt;strong&gt;유저의 요청보다 먼저 렌더링될 수 있는 페이지에 좋습니다&lt;/strong&gt;. 또한 추가적인 데이터를 받아오는 클라이언트 사이드 렌더링과 함께 사용할 수 있습니다.&lt;/li&gt;
&lt;li&gt;Server Side Rendering: &lt;strong&gt;HTML은 각각의 요청에 생성됩니다.&lt;/strong&gt; 서버사이드 렌더링의 결과는 &lt;strong&gt;Static Generation보다 성능이 더 느리기 때문에, 꼭 필요할 때만 사용하는 것이 필요합니다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3&gt;Fast Refresh&lt;/h3&gt;
&lt;p&gt;Fast Refresh는 React구성 요소에 대한 편집(edit) 사항에 대한 즉각적인 피드백을 제공하는 Next.js기능입니다. Fast Refresh는 9.4이상의 Next.js애플리케이션에서 기본적으로 활성화 되어있습니다. Next.js의 Fast Refresh가 활성화되면 component state를 잃지 않고 대부분의 편집 내용이 1초 이내에 표시되어야 합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;만약에 React components를 export를 한다면, Fast Refresh는 그 파일을 업데이트하고, 너의 컴포넌트를 리렌더링할 것입니다. styles, 렌더링 로직, 이벤트 핸들러 등 어떤 것도 수정할 수 있습니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;마지막으로 React트리 외부의 파일에서 가져온 파일을 편집하는 경우 빠른 새로 고침은 전체 로드를 수행하는 것으로 대체됩니다&lt;/strong&gt;. React구성요소를 렌더링하지만 &lt;strong&gt;non-React component에서 가져온 값을 내보내는 파일&lt;/strong&gt;이 있을 수 있습니다**.** (ex.. 변수들 등) 이러한 경우에 이 파일들을 별도의 파일로 마이그레이션하고 두 파일로 가져오는 것을 고려해야 한다. 이렇게 하면 빠른 새로고침이 다시 활성화됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3&gt;Client Side Routing&lt;/h3&gt;
&lt;p&gt;Next.js router를 사용하면 단일 페이지 애플리케이션과 유사하게 페이지 간에 클라이언트 측 경로 전환을 수행할 수 있습니다. 뷰포트의 모든 &lt;Link /&gt;(초기 또는 스크롤을 통해)는 정적 생성을 사용하는 페이지에 대해 기본적으로(해당 데이터 포함) 미리 가져(prefetch)옵니다. 서버 렌더링 경로에 대한 해당 데이터는 미리 가져오지 않습니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;API Routes&lt;/h3&gt;
&lt;p&gt;API Routes는 Next.js로 API를 빌드하기 위한 솔루션을 제공합니다.&lt;/p&gt;
&lt;p&gt;페이지/api 폴더 내의 모든 파일은 /api/*에 매핑되며 페이지 대신 API end point로 처리됩니다. 서버 측 전용 번들이며 클라이언트 측 번들 크기를 늘리지 않습니다.&lt;/p&gt;
&lt;p&gt;예를 들어 다음 API 경로 pages/api/user.js는 상태 코드가 200인 json 응답을 반환합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;req&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; res&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  res&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;John Doe&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;API 경로가 작동하려면 함수를 기본(요청 핸들러라고도 함)로 내보내야 합니다. 그러면 다음 매개변수가 수신됩니다.&lt;/p&gt;
&lt;p&gt;API route가 작동하기 위해, 밑의 파라미터들을 받는 default(ex. request handler)로서 함수를 export하는 것을 필요로 합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“req” : &lt;a href=&quot;https://nextjs.org/docs/api-routes/api-middlewares&quot;&gt;pre-built middlewares&lt;/a&gt; 추가한 &lt;a href=&quot;https://nodejs.org/api/http.html#http_class_http_incomingmessage&quot;&gt;http.IncomingMessage&lt;/a&gt;의 인스턴스&lt;/li&gt;
&lt;li&gt;“res”: :&lt;a href=&quot;https://nextjs.org/docs/api-routes/response-helpers&quot;&gt;helper functions&lt;/a&gt;를 추가한 &lt;a href=&quot;https://nodejs.org/api/http.html#http_class_http_serverresponse&quot;&gt;http.ServerResponse&lt;/a&gt; 인스턴스&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;API route에서 다른 HTTP 메소드를 다루기 위해, request handler로 &lt;code class=&quot;language-text&quot;&gt;req.method&lt;/code&gt; 사용할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;req&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; res&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;req&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;method &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;POST&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// Process a POST request&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// Handle any other HTTP method&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;새로운 프로젝트를 위해, API Route와 함께 전체의 API를 빌드할 수 있습니다. 만약에 API가 존재한다면, API Route를 통한 API호출을 필요로 하지 않을 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;외부 서비스의 URL 마스킹(masking) (ex. “&lt;a href=&quot;https://company.com/secret-url%E2%80%9D&quot;&gt;https://company.com/secret-url”&lt;/a&gt; 대신에 “/api/secret”)&lt;/li&gt;
&lt;li&gt;서버에서 환경 변수를 사용하여 외부 서비스에 안전하게 액세스합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;주의사항&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API Route는 CORS 헤더를 지정하지 않습니다. 즉, 기본적으로만 동일한 출처임을 의미합니다. 요청 처리기를 CORS 미들웨어로 래핑하여 이러한 동작을 사용자 지정할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[useState가 async인 이유]]></title><description><![CDATA[참고:https://github.com/facebook/react/issues/11527 참고: jinsunee velog 1.내부의 일관성 보장(Guaranteeing Internal Consistency) 만약 state…]]></description><link>https://gatsbystarterblogsource.gatsbyjs.io/React/</link><guid isPermaLink="false">https://gatsbystarterblogsource.gatsbyjs.io/React/</guid><pubDate>Tue, 15 Feb 2022 01:00:00 GMT</pubDate><content:encoded>&lt;p&gt;참고:&lt;a href=&quot;https://github.com/facebook/react/issues/11527&quot;&gt;https://github.com/facebook/react/issues/11527&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;참고: &lt;a href=&quot;https://velog.io/@jinsunee/setState%EA%B0%80-%EB%B9%84%EB%8F%99%EA%B8%B0%ED%95%A8%EC%88%98%EC%9D%B8-%EC%9D%B4%EC%9C%A0&quot;&gt;jinsunee velog&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;1.내부의 일관성 보장(Guaranteeing Internal Consistency)&lt;/h2&gt;
&lt;p&gt;만약 state가 동기적으로 업데이트 된다고 해도, props는 아니다.(너는 부모의 컴포넌트가 리렌더링 될 때까지 props를 알 수가 없고, 만약에 동기적으로 된다면 batching(일괄처리)는 필요없을 것이다.&lt;/p&gt;
&lt;p&gt;현재 React에서 제공하는 객체(state,props,refs)는 내부적으로 서로 일치한다. 즉, 하나의 개체만 사용하는 경우, 완전히 조정(reconciled)된 트리를 참조하도록 보장된다.&lt;/p&gt;
&lt;p&gt;근데 만약 state만 동기적으로 발생한다면 ?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 0&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; value&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 1&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; value&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 2&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 0&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;onIncrement&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; value&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 0&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;onIncrement&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;state만 동기적으로 실행된다면 this.state는 즉시 값을 출력할 수 있다. 하지만 props는 부모의 리렌더링 없이 리렌더링 할 수 없다. 이것이 의미하는 것은 우리는 batch(일괄처리)를 포기해야 한다는 것이다.&lt;/p&gt;
&lt;p&gt;이러한 예는 이론에서만 나타나는 것이 아니다. React Redux는 React state가 아닌 것과 props를 혼합하였기 떄문에 이러한 종류의 문제들을 겪곤 했다.&lt;/p&gt;
&lt;p&gt;이러한 문제를 리액트는 this.state 와 this.props를 재조정(reconciliation)후에 업데이트 한다. 그래서 리팩토링 전후에 모두 0이 인쇄되는 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;이러한 문제는 특정한 경우엔 상당히 불편하다. 특히 한 곳에서 완전한 상태 업데이트를 표현하는 방법을 생각하는 대신에, 더 많은 배경에서 상태를 여러 번 변경하는 것을 생각한 사람들에게는 불편할 수 있다. 이 부분에 대해상태 업데이트를 한 곳에서 집중적으로 유지하는 것이 디버깅 관점에서는 더 명확하다고 생각하지만, 위의 부분도 공감하고 있다.&lt;/p&gt;
&lt;p&gt;요악하자면, &lt;strong&gt;React 모델은 항상 간결한 코드로 이끌지는 않지만 내부적으로 일관성이 있고 상태를 올리는 것이 안전하다는 것을 보장하고 있다.&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;2. 동시 업데이트 활성화(Enabling Concurrent Updates)&lt;/h2&gt;
&lt;p&gt;컨셉적으로, React는 구성 요소 당 하나의 업데이트 대기열이 있는 것처럼 작동한다. 이것이 논의가 필요없는 이유는 업데이트가 한 곳에서 비동기적으로 정확한 순서로 진행되기 때문이다.&lt;/p&gt;
&lt;p&gt;우리가 “비동기 렌더링”을 설명한 한 가지 방법은 이벤트 핸들러, 네트워크 응답, 애니메이션 등의 출처에 따라 React가 setState()호출에 다른 우선 순위를 할당할 수 있다는 것이다.&lt;/p&gt;
&lt;p&gt;예를들어, 만약에 우리가 메시지를 타이핑한다면, TextBox 컴포넌트안에 있는 타이핑 setState()을 즉시 호출해야 한다. 하지만 만약에 타이핑하는 동안 새로운 메시지를 받는 다면, 스레드 차단으로 인해 입력이 더듬거리게 하는 것보다 새 MessageBubble의 렌더링을 특정 시간 값까지 지연시키는 것이 더 나을 것이다.&lt;/p&gt;
&lt;p&gt;만약에 우리가 특정 업데이트가 “낮은 우선순위”를 갖도록 하면 렌더링을 몇 밀리초의 작은 덩어리로 분할하여 사용자에게 눈에 띄지 않게 할 수 있다.&lt;/p&gt;
&lt;p&gt;하지만 이렇게 하다보면 성능이 낮다고 생각할수도 있다. 하지만 &lt;strong&gt;비동기적 렌더링은 성능 최적화에만 국한 되지 않는다. 우리는 이것이 React컴포넌트 모델이 할 수 있는 근본적인 변화라고 생각한다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;예를 들어, 화면이 또 다른 화면으로 이동하는 경우를 고려해보자. 너는 새로운 화면이 렌더링되는 동안 로딩 스피너를 보여줄 것이다.&lt;/p&gt;
&lt;p&gt;하지만 만약에 이동이 빠르게 일어난다면, 계속해서 스피너를 호출하고 이동하여, 바로 스피너를 숨기면 사용자 경험이 저하된다. 더군다나 비동기 종속성(데이터,코드,이미지)이 서로 다른 여러 수준의 컴포넌트들이 있는 경우, 하나씩 짧게 깜박이는 스피너가 발생하게 된다. 이것은 시각적으로 좋지 않고, 모든 DOM reflow 때문에 실제로 앱을 느리게 만든다.&lt;/p&gt;
&lt;p&gt;만약에 너가 단순하게 다른 뷰를 렌더링하는 setState를 사용할 때, “background”에서 업데이트 된뷰를 렌더링하는 것을 시작할 수 있다면 좋지 않을까? 너가 어떠한 조정코드 없이, 특정한 시간보다 업데이트가 더 걸린다면 스피너를 보여줄 수 있는 것을 선택할 수 있고, 그렇지 않으면 전체의 새로운 하위트리의 async dependencies가 만족될 때 React가 원활한 변화를 수행하도록 한다고 상상해보자. 더욱, 우리가 대기하는 동안 “이전 화면”은 interactive하게 유지되고(다른 요소로 변하는(transition) 것을 선택할 수 있는 등) React는 시간이 너무 오래 걸리면 스피너를 표시해야 한다고 강제한다.&lt;/p&gt;
&lt;p&gt;현재 React 모델과 수명 주기에 대한 약간의 조정으로 우리는 실제로 이것을 구현했다. 이것은 this.state가 “동기적”으로 실행되지 않기 떄문에 가능하다. 즉시 실행되면 “이전 버전”이 여전히 볼수 있고 interactive한 동안에 background에서 새로운 버전을 렌더링하는 것을 실현할 방법이 없다.&lt;/p&gt;
&lt;h2&gt;리렌더링 방지&lt;/h2&gt;
&lt;p&gt;React는 state,props값에 따라 리렌더링이 일어난다.&lt;/p&gt;
&lt;p&gt;만약에 state가 동기적이고, 하나의 이벤트안에 3개의 state가 변경된다면 3번의 리렌더링이 발생한다. 이에 대비하여 setState를 비동기 함수로 처리해서 컴포넌트 내의 비동기 함수를 처리하는 콜백 큐가 다 비워지면 리렌더링하도록 설계되었다.&lt;/p&gt;</content:encoded></item></channel></rss>